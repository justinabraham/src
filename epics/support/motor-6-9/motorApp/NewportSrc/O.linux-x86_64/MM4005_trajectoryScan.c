/* C code for program MM4005_trajectoryScan, generated by snc from ../MM4005_trajectoryScan.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 12 "../MM4005_trajectoryScan.st"
#include <stdlib.h>
# line 13 "../MM4005_trajectoryScan.st"
#include <string.h>
# line 14 "../MM4005_trajectoryScan.st"
#include <stdio.h>
# line 15 "../MM4005_trajectoryScan.st"
#include <epicsString.h>
# line 16 "../MM4005_trajectoryScan.st"
#include <asynOctetSyncIO.h>
# line 243 "../trajectoryScan.h"
static const EF_ID buildMon = 1;
# line 244 "../trajectoryScan.h"
static const EF_ID executeMon = 2;
# line 245 "../trajectoryScan.h"
static const EF_ID execStateMon = 3;
# line 246 "../trajectoryScan.h"
static const EF_ID abortMon = 4;
# line 247 "../trajectoryScan.h"
static const EF_ID readbackMon = 5;
# line 248 "../trajectoryScan.h"
static const EF_ID nelementsMon = 6;
# line 249 "../trajectoryScan.h"
static const EF_ID motorMDVSMon = 7;
# line 99 "../MM4005_trajectoryScan.st"
static int writeOnly(SS_ID ssId, struct UserVar *pVar, char *command);
# line 100 "../MM4005_trajectoryScan.st"
static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command);
# line 101 "../MM4005_trajectoryScan.st"
static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos);
# line 102 "../MM4005_trajectoryScan.st"
static int getMotorMoving(SS_ID ssId, struct UserVar *pVar);
# line 103 "../MM4005_trajectoryScan.st"
static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar);
# line 104 "../MM4005_trajectoryScan.st"
static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar);

/* Variable declarations */
struct seqg_vars {
# line 40 "../trajectoryScan.h"
	int debugLevel;
# line 42 "../trajectoryScan.h"
	int numAxes;
# line 44 "../trajectoryScan.h"
	int nelements;
# line 46 "../trajectoryScan.h"
	int npulses;
# line 48 "../trajectoryScan.h"
	int startPulses;
# line 50 "../trajectoryScan.h"
	int endPulses;
# line 52 "../trajectoryScan.h"
	int nactual;
# line 53 "../trajectoryScan.h"
	int moveMode;
# line 55 "../trajectoryScan.h"
	double time_PV;
# line 57 "../trajectoryScan.h"
	double timeScale;
# line 59 "../trajectoryScan.h"
	int timeMode;
# line 61 "../trajectoryScan.h"
	double accel;
# line 63 "../trajectoryScan.h"
	int build;
# line 65 "../trajectoryScan.h"
	int buildState;
# line 66 "../trajectoryScan.h"
	int buildStatus;
# line 67 "../trajectoryScan.h"
	string buildMessage;
# line 68 "../trajectoryScan.h"
	int simMode;
# line 70 "../trajectoryScan.h"
	int execute;
# line 72 "../trajectoryScan.h"
	int execState;
# line 74 "../trajectoryScan.h"
	int execStatus;
# line 75 "../trajectoryScan.h"
	string execMessage;
# line 76 "../trajectoryScan.h"
	int abort;
# line 78 "../trajectoryScan.h"
	int readback;
# line 80 "../trajectoryScan.h"
	int readState;
# line 81 "../trajectoryScan.h"
	int readStatus;
# line 82 "../trajectoryScan.h"
	string readMessage;
# line 83 "../trajectoryScan.h"
	double timeTrajectory[2000];
# line 86 "../trajectoryScan.h"
	string trajectoryFile;
# line 89 "../trajectoryScan.h"
	int moveAxis[8];
# line 101 "../trajectoryScan.h"
	double motorTrajectory[8][2000];
# line 113 "../trajectoryScan.h"
	double motorReadbacks[8][2000];
# line 124 "../trajectoryScan.h"
	double motorError[8][2000];
# line 135 "../trajectoryScan.h"
	double motorCurrent[8];
# line 146 "../trajectoryScan.h"
	double motorMDVS[8];
# line 158 "../trajectoryScan.h"
	double motorMDVA[8];
# line 169 "../trajectoryScan.h"
	int motorMDVE[8];
# line 180 "../trajectoryScan.h"
	double motorMVA[8];
# line 191 "../trajectoryScan.h"
	int motorMVE[8];
# line 202 "../trajectoryScan.h"
	double motorMAA[8];
# line 213 "../trajectoryScan.h"
	int motorMAE[8];
# line 226 "../trajectoryScan.h"
	double epicsMotorPos[8];
# line 230 "../trajectoryScan.h"
	double epicsMotorDir[8];
# line 234 "../trajectoryScan.h"
	double epicsMotorOff[8];
# line 238 "../trajectoryScan.h"
	double epicsMotorDone[8];
# line 64 "../MM4005_trajectoryScan.st"
	char stringOut[256];
# line 65 "../MM4005_trajectoryScan.st"
	char stringIn[256];
# line 66 "../MM4005_trajectoryScan.st"
	char *asynPort;
# line 67 "../MM4005_trajectoryScan.st"
	char *pasynUser;
# line 68 "../MM4005_trajectoryScan.st"
	int status;
# line 69 "../MM4005_trajectoryScan.st"
	int i;
# line 70 "../MM4005_trajectoryScan.st"
	int j;
# line 71 "../MM4005_trajectoryScan.st"
	int k;
# line 72 "../MM4005_trajectoryScan.st"
	double delay;
# line 73 "../MM4005_trajectoryScan.st"
	int anyMoving;
# line 74 "../MM4005_trajectoryScan.st"
	int ncomplete;
# line 75 "../MM4005_trajectoryScan.st"
	int nextra;
# line 76 "../MM4005_trajectoryScan.st"
	int npoints;
# line 77 "../MM4005_trajectoryScan.st"
	int dir;
# line 78 "../MM4005_trajectoryScan.st"
	double dtime;
# line 79 "../MM4005_trajectoryScan.st"
	double dpos;
# line 80 "../MM4005_trajectoryScan.st"
	double posActual;
# line 81 "../MM4005_trajectoryScan.st"
	double posTheory;
# line 82 "../MM4005_trajectoryScan.st"
	double expectedTime;
# line 83 "../MM4005_trajectoryScan.st"
	double initialPos[8];
# line 84 "../MM4005_trajectoryScan.st"
	char macroBuf[100];
# line 85 "../MM4005_trajectoryScan.st"
	char motorName[100];
# line 86 "../MM4005_trajectoryScan.st"
	char *p;
# line 87 "../MM4005_trajectoryScan.st"
	char *tok_save;
# line 91 "../MM4005_trajectoryScan.st"
	int motorCurrentIndex[8];
# line 92 "../MM4005_trajectoryScan.st"
	int epicsMotorDoneIndex[8];
# line 96 "../MM4005_trajectoryScan.st"
	unsigned long startTime;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "trajectoryScan" ******/

/* Event function for state "init" in state set "trajectoryScan" */
static seqBool seqg_event_trajectoryScan_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "trajectoryScan" */
static void seqg_action_trajectoryScan_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 113 "../MM4005_trajectoryScan.st"
			if (seqg_var->numAxes > 8)
# line 113 "../MM4005_trajectoryScan.st"
				seqg_var->numAxes = 8;
# line 114 "../MM4005_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numAxes; seqg_var->i++)
			{
# line 115 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->macroBuf, "M%d", seqg_var->i + 1);
# line 116 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VAL", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 117 "../MM4005_trajectoryScan.st"
				seq_pvAssign(seqg_env, 124/*epicsMotorPos*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 118 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DIR", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 119 "../MM4005_trajectoryScan.st"
				seq_pvAssign(seqg_env, 132/*epicsMotorDir*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 120 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.OFF", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 121 "../MM4005_trajectoryScan.st"
				seq_pvAssign(seqg_env, 140/*epicsMotorOff*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 122 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DMOV", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 123 "../MM4005_trajectoryScan.st"
				seq_pvAssign(seqg_env, 148/*epicsMotorDone*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
			}
# line 126 "../MM4005_trajectoryScan.st"
			seqg_var->asynPort = seq_macValueGet(seqg_env, "PORT");
			pVar->status = pasynOctetSyncIO->connect(pVar->asynPort, 0,
			(asynUser **)&pVar->pasynUser,
			NULL);
# line 130 "../MM4005_trajectoryScan.st"
			if (seqg_var->status != 0)
			{
# line 131 "../MM4005_trajectoryScan.st"
				printf("trajectoryScan error in pasynOctetSyncIO->connect\n");
# line 132 "../MM4005_trajectoryScan.st"
				printf("   status=%d, port=%s\n", seqg_var->status, seqg_var->asynPort);
			}
# line 134 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 135 "../MM4005_trajectoryScan.st"
				seqg_var->motorCurrentIndex[seqg_var->j] = seq_pvIndex(seqg_env, 60/*motorCurrent*/ + (CH_ID)(seqg_var->j));
# line 136 "../MM4005_trajectoryScan.st"
				seqg_var->epicsMotorDoneIndex[seqg_var->j] = seq_pvIndex(seqg_env, 148/*epicsMotorDone*/ + (CH_ID)(seqg_var->j));
			}
# line 139 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 140 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dGC?", seqg_var->j + 1);
				writeRead(ssId, pVar, pVar->stringOut);
# line 143 "../MM4005_trajectoryScan.st"
				seqg_var->motorMDVS[seqg_var->j] = atof(seqg_var->stringIn + 3);
# line 144 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 68/*motorMDVS*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 147 "../MM4005_trajectoryScan.st"
			seq_efClear(seqg_env, buildMon);
# line 148 "../MM4005_trajectoryScan.st"
			seq_efClear(seqg_env, executeMon);
# line 149 "../MM4005_trajectoryScan.st"
			seq_efClear(seqg_env, abortMon);
# line 150 "../MM4005_trajectoryScan.st"
			seq_efClear(seqg_env, readbackMon);
# line 151 "../MM4005_trajectoryScan.st"
			seq_efClear(seqg_env, nelementsMon);
# line 152 "../MM4005_trajectoryScan.st"
			seq_efClear(seqg_env, motorMDVSMon);
		}
		return;
	}
}

/****** Code for state "monitor_inputs" in state set "trajectoryScan" ******/

/* Event function for state "monitor_inputs" in state set "trajectoryScan" */
static seqBool seqg_event_trajectoryScan_0_monitor_inputs(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 159 "../MM4005_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, buildMon) && (seqg_var->build == 1))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 162 "../MM4005_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, executeMon) && (seqg_var->execute == 1))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 165 "../MM4005_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, readbackMon) && (seqg_var->readback == 1))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 168 "../MM4005_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, nelementsMon) && (seqg_var->nelements >= 1))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 176 "../MM4005_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, motorMDVSMon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 4;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitor_inputs" in state set "trajectoryScan" */
static void seqg_action_trajectoryScan_0_monitor_inputs(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	case 1:
		{
		}
		return;
	case 2:
		{
		}
		return;
	case 3:
		{
# line 172 "../MM4005_trajectoryScan.st"
			seqg_var->endPulses = seqg_var->nelements;
# line 173 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 5/*endPulses*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
# line 180 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 181 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dGC%f", seqg_var->j + 1, seqg_var->motorMDVS[seqg_var->j]);
				writeOnly(ssId, pVar, pVar->stringOut);
			}
		}
		return;
	}
}

/****** Code for state "build" in state set "trajectoryScan" ******/

/* Event function for state "build" in state set "trajectoryScan" */
static seqBool seqg_event_trajectoryScan_0_build(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "build" in state set "trajectoryScan" */
static void seqg_action_trajectoryScan_0_build(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 192 "../MM4005_trajectoryScan.st"
			seqg_var->buildState = 1;
# line 193 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 194 "../MM4005_trajectoryScan.st"
			seqg_var->buildStatus = 0;
# line 195 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 197 "../MM4005_trajectoryScan.st"
			strcpy(seqg_var->stringOut, "NC");
			writeOnly(ssId, pVar, pVar->stringOut);
# line 200 "../MM4005_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numAxes; seqg_var->i++)
			{
# line 201 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dDC%d", seqg_var->i + 1, seqg_var->moveAxis[seqg_var->i]);
				writeOnly(ssId, pVar, pVar->stringOut);
			}
# line 205 "../MM4005_trajectoryScan.st"
			sprintf(seqg_var->stringOut, "UC%f", seqg_var->accel);
			writeOnly(ssId, pVar, pVar->stringOut);
# line 209 "../MM4005_trajectoryScan.st"
			if (seqg_var->timeMode == 0)
			{
# line 210 "../MM4005_trajectoryScan.st"
				seqg_var->dtime = seqg_var->time_PV / seqg_var->nelements;
# line 211 "../MM4005_trajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->nelements; seqg_var->i++)
# line 211 "../MM4005_trajectoryScan.st"
					seqg_var->timeTrajectory[seqg_var->i] = seqg_var->dtime;
# line 212 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 26/*timeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 219 "../MM4005_trajectoryScan.st"
			if (seqg_var->moveMode == 0)
			{
# line 220 "../MM4005_trajectoryScan.st"
				seqg_var->npoints = seqg_var->nelements;
			}
			else
			{
# line 222 "../MM4005_trajectoryScan.st"
				seqg_var->npoints = seqg_var->nelements - 1;
			}
# line 224 "../MM4005_trajectoryScan.st"
			seqg_var->nextra = (seqg_var->npoints % 4);
# line 225 "../MM4005_trajectoryScan.st"
			if (seqg_var->nextra != 0)
			{
# line 226 "../MM4005_trajectoryScan.st"
				seqg_var->nextra = 4 - seqg_var->nextra;
# line 229 "../MM4005_trajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->nextra; seqg_var->i++)
				{
# line 230 "../MM4005_trajectoryScan.st"
					seqg_var->timeTrajectory[seqg_var->npoints + seqg_var->i] = 0.1;
# line 231 "../MM4005_trajectoryScan.st"
					for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
					{
# line 232 "../MM4005_trajectoryScan.st"
						if (!seqg_var->moveAxis[seqg_var->j])
							continue;
# line 233 "../MM4005_trajectoryScan.st"
						if (seqg_var->moveMode == 0)
						{
# line 236 "../MM4005_trajectoryScan.st"
							seqg_var->motorTrajectory[seqg_var->j][seqg_var->nelements + seqg_var->i] = seqg_var->motorTrajectory[seqg_var->j][seqg_var->nelements - 1] * 0.1 / seqg_var->timeTrajectory[seqg_var->nelements - 1];
						}
						else
						{
# line 240 "../MM4005_trajectoryScan.st"
							seqg_var->dpos = (seqg_var->motorTrajectory[seqg_var->j][seqg_var->nelements - 1] - seqg_var->motorTrajectory[seqg_var->j][seqg_var->nelements - 2]) * 0.1 / seqg_var->timeTrajectory[seqg_var->nelements - 2];
# line 243 "../MM4005_trajectoryScan.st"
							seqg_var->motorTrajectory[seqg_var->j][seqg_var->nelements + seqg_var->i] = seqg_var->motorTrajectory[seqg_var->j][seqg_var->nelements - 1] + seqg_var->dpos * (seqg_var->i + 1);
						}
					}
				}
# line 247 "../MM4005_trajectoryScan.st"
				seqg_var->nelements += seqg_var->nextra;
# line 248 "../MM4005_trajectoryScan.st"
				seqg_var->npoints += seqg_var->nextra;
# line 249 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 2/*nelements*/, DEFAULT, DEFAULT_TIMEOUT);
# line 250 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 26/*timeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
# line 252 "../MM4005_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 253 "../MM4005_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 36/*motorTrajectory*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
# line 257 "../MM4005_trajectoryScan.st"
			seqg_var->expectedTime = 0;
# line 258 "../MM4005_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->npoints; seqg_var->i++)
# line 259 "../MM4005_trajectoryScan.st"
				seqg_var->expectedTime += seqg_var->timeTrajectory[seqg_var->i];
# line 261 "../MM4005_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->npoints; seqg_var->i++)
			{
# line 262 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->buildMessage, "Building element %d/%d", seqg_var->i + 1, seqg_var->nelements);
# line 263 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 264 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dDT%f", seqg_var->i + 1, seqg_var->timeTrajectory[seqg_var->i]);
				writeOnly(ssId, pVar, pVar->stringOut);
# line 266 "../MM4005_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 267 "../MM4005_trajectoryScan.st"
					if (!seqg_var->moveAxis[seqg_var->j])
						continue;
# line 268 "../MM4005_trajectoryScan.st"
					if (seqg_var->moveMode == 0)
					{
# line 269 "../MM4005_trajectoryScan.st"
						seqg_var->dpos = seqg_var->motorTrajectory[seqg_var->j][seqg_var->i];
					}
					else
					{
# line 271 "../MM4005_trajectoryScan.st"
						seqg_var->dpos = seqg_var->motorTrajectory[seqg_var->j][seqg_var->i + 1] - seqg_var->motorTrajectory[seqg_var->j][seqg_var->i];
					}
# line 274 "../MM4005_trajectoryScan.st"
					if (seqg_var->epicsMotorDir[seqg_var->j] == 0)
# line 274 "../MM4005_trajectoryScan.st"
						seqg_var->dir = 1;
					else
# line 274 "../MM4005_trajectoryScan.st"
						seqg_var->dir = -1;
# line 275 "../MM4005_trajectoryScan.st"
					seqg_var->dpos = seqg_var->dpos * seqg_var->dir;
# line 276 "../MM4005_trajectoryScan.st"
					sprintf(seqg_var->stringOut, "%dDX%f", seqg_var->j + 1, seqg_var->dpos);
					writeOnly(ssId, pVar, pVar->stringOut);
				}
# line 282 "../MM4005_trajectoryScan.st"
				if (((seqg_var->i + 1) % 20) == 0)
					writeRead(ssId, pVar, "TB");
			}
# line 285 "../MM4005_trajectoryScan.st"
			if (seqg_var->npulses > 0)
			{
# line 287 "../MM4005_trajectoryScan.st"
				if (seqg_var->startPulses < 1)
# line 287 "../MM4005_trajectoryScan.st"
					seqg_var->startPulses = 1;
# line 288 "../MM4005_trajectoryScan.st"
				if (seqg_var->startPulses > seqg_var->npoints)
# line 288 "../MM4005_trajectoryScan.st"
					seqg_var->startPulses = seqg_var->npoints;
# line 289 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 4/*startPulses*/, DEFAULT, DEFAULT_TIMEOUT);
# line 290 "../MM4005_trajectoryScan.st"
				if (seqg_var->endPulses < seqg_var->startPulses)
# line 290 "../MM4005_trajectoryScan.st"
					seqg_var->endPulses = seqg_var->startPulses;
# line 291 "../MM4005_trajectoryScan.st"
				if (seqg_var->endPulses > seqg_var->npoints)
# line 291 "../MM4005_trajectoryScan.st"
					seqg_var->endPulses = seqg_var->npoints;
# line 292 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 5/*endPulses*/, DEFAULT, DEFAULT_TIMEOUT);
# line 296 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "MB%d,ME%d,MN%d", seqg_var->startPulses, seqg_var->endPulses, seqg_var->npulses + 1);
				writeOnly(ssId, pVar, pVar->stringOut);
			}
# line 300 "../MM4005_trajectoryScan.st"
			strcpy(seqg_var->buildMessage, "Verifying trajectory");
# line 301 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 302 "../MM4005_trajectoryScan.st"
			strcpy(seqg_var->stringOut, "VC");
			writeOnly(ssId, pVar, pVar->stringOut);
			writeRead(ssId, pVar, "TB");
# line 307 "../MM4005_trajectoryScan.st"
			if (seqg_var->stringIn[2] == '@')
			{
# line 308 "../MM4005_trajectoryScan.st"
				seqg_var->buildStatus = 1;
# line 309 "../MM4005_trajectoryScan.st"
				strcpy(seqg_var->buildMessage, " ");
			}
			else
			{
# line 311 "../MM4005_trajectoryScan.st"
				seqg_var->buildStatus = 2;
# line 312 "../MM4005_trajectoryScan.st"
				strncpy(seqg_var->buildMessage, seqg_var->stringIn, 40 - 1);
			}
# line 315 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 316 "../MM4005_trajectoryScan.st"
				seqg_var->p = seqg_var->stringIn;
# line 319 "../MM4005_trajectoryScan.st"
				if (!seqg_var->moveAxis[seqg_var->j])
					continue;
# line 323 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dRC1", seqg_var->j + 1);
				writeRead(ssId, pVar, pVar->stringOut);
# line 325 "../MM4005_trajectoryScan.st"
				seqg_var->motorMDVE[seqg_var->j] = atoi(seqg_var->p + 3);
# line 326 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 84/*motorMDVE*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 327 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dRC2", seqg_var->j + 1);
				writeRead(ssId, pVar, pVar->stringOut);
# line 329 "../MM4005_trajectoryScan.st"
				seqg_var->motorMDVA[seqg_var->j] = atof(seqg_var->p + 3);
# line 330 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 76/*motorMDVA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 332 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dRC3", seqg_var->j + 1);
				writeRead(ssId, pVar, pVar->stringOut);
# line 334 "../MM4005_trajectoryScan.st"
				seqg_var->motorMVE[seqg_var->j] = atoi(seqg_var->p + 3);
# line 335 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 100/*motorMVE*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 336 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dRC4", seqg_var->j + 1);
				writeRead(ssId, pVar, pVar->stringOut);
# line 338 "../MM4005_trajectoryScan.st"
				seqg_var->motorMVA[seqg_var->j] = atof(seqg_var->p + 3);
# line 339 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 92/*motorMVA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 341 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dRC5", seqg_var->j + 1);
				writeRead(ssId, pVar, pVar->stringOut);
# line 343 "../MM4005_trajectoryScan.st"
				seqg_var->motorMAE[seqg_var->j] = atoi(seqg_var->p + 3);
# line 344 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 116/*motorMAE*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 345 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dRC6", seqg_var->j + 1);
				writeRead(ssId, pVar, pVar->stringOut);
# line 347 "../MM4005_trajectoryScan.st"
				seqg_var->motorMAA[seqg_var->j] = atof(seqg_var->p + 3);
# line 348 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 108/*motorMAA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 351 "../MM4005_trajectoryScan.st"
			seqg_var->buildState = 0;
# line 352 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 353 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 354 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 357 "../MM4005_trajectoryScan.st"
			seqg_var->build = 0;
# line 358 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 12/*build*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "execute" in state set "trajectoryScan" ******/

/* Event function for state "execute" in state set "trajectoryScan" */
static seqBool seqg_event_trajectoryScan_0_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "execute" in state set "trajectoryScan" */
static void seqg_action_trajectoryScan_0_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 366 "../MM4005_trajectoryScan.st"
			seqg_var->execState = 1;
# line 367 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 369 "../MM4005_trajectoryScan.st"
			seqg_var->execStatus = 0;
# line 370 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 372 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
# line 372 "../MM4005_trajectoryScan.st"
				seqg_var->initialPos[seqg_var->j] = seqg_var->epicsMotorPos[seqg_var->j];
# line 374 "../MM4005_trajectoryScan.st"
			if (seqg_var->moveMode == 1)
			{
# line 375 "../MM4005_trajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 376 "../MM4005_trajectoryScan.st"
					if (!seqg_var->moveAxis[seqg_var->j])
						continue;
# line 377 "../MM4005_trajectoryScan.st"
					seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorTrajectory[seqg_var->j][0];
# line 378 "../MM4005_trajectoryScan.st"
					seq_pvPutTmo(seqg_env, 124/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
				waitEpicsMotors(ssId, pVar);
			}
# line 384 "../MM4005_trajectoryScan.st"
			sprintf(seqg_var->stringOut, "LS,%dEC%f", seqg_var->simMode, seqg_var->timeScale);
			writeOnly(ssId, pVar, pVar->stringOut);
# line 387 "../MM4005_trajectoryScan.st"
			seqg_var->startTime = time(0);
# line 388 "../MM4005_trajectoryScan.st"
			seqg_var->execState = 2;
# line 389 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 391 "../MM4005_trajectoryScan.st"
			epicsThreadSleep(0.1);
		}
		return;
	}
}

/****** Code for state "wait_execute" in state set "trajectoryScan" ******/

/* Event function for state "wait_execute" in state set "trajectoryScan" */
static seqBool seqg_event_trajectoryScan_0_wait_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 398 "../MM4005_trajectoryScan.st"
	if (seqg_var->execStatus == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 410 "../MM4005_trajectoryScan.st"
	if (seqg_var->execState == 2)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 444 "../MM4005_trajectoryScan.st"
	if (seqg_var->execState == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "wait_execute" in state set "trajectoryScan" */
static void seqg_action_trajectoryScan_0_wait_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 402 "../MM4005_trajectoryScan.st"
			seqg_var->execState = 0;
# line 403 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 406 "../MM4005_trajectoryScan.st"
			seqg_var->execute = 0;
# line 407 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 412 "../MM4005_trajectoryScan.st"
			getMotorPositions(ssId, pVar, pVar->motorCurrent);
# line 413 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
# line 413 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 60/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			writeRead(ssId, pVar, "XC1");
# line 417 "../MM4005_trajectoryScan.st"
			seqg_var->ncomplete = atoi(&seqg_var->stringIn[2]);
# line 419 "../MM4005_trajectoryScan.st"
			sprintf(seqg_var->execMessage, "Executing element %d/%d", seqg_var->ncomplete, seqg_var->nelements);
# line 420 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			pVar->anyMoving = getMotorMoving(ssId, pVar);
# line 422 "../MM4005_trajectoryScan.st"
			if (!seqg_var->anyMoving)
			{
# line 423 "../MM4005_trajectoryScan.st"
				seqg_var->execState = 3;
# line 424 "../MM4005_trajectoryScan.st"
				seqg_var->execStatus = 1;
# line 425 "../MM4005_trajectoryScan.st"
				strcpy(seqg_var->execMessage, " ");
			}
# line 428 "../MM4005_trajectoryScan.st"
			if (difftime(time(0), seqg_var->startTime) > seqg_var->expectedTime * seqg_var->timeScale * 2.)
			{
# line 429 "../MM4005_trajectoryScan.st"
				seqg_var->execState = 3;
# line 430 "../MM4005_trajectoryScan.st"
				seqg_var->execStatus = 4;
# line 431 "../MM4005_trajectoryScan.st"
				strcpy(seqg_var->execMessage, "Timeout");
			}
			writeRead(ssId, pVar, "TB");
# line 437 "../MM4005_trajectoryScan.st"
			if (seqg_var->stringIn[2] != '@')
			{
# line 438 "../MM4005_trajectoryScan.st"
				seqg_var->execState = 3;
# line 439 "../MM4005_trajectoryScan.st"
				seqg_var->execStatus = 2;
# line 440 "../MM4005_trajectoryScan.st"
				strncpy(seqg_var->execMessage, seqg_var->stringIn, 40 - 1);
			}
		}
		return;
	case 2:
		{
# line 445 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 446 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 447 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			getMotorPositions(ssId, pVar, pVar->motorCurrent);
# line 450 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
# line 450 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 60/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 451 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 452 "../MM4005_trajectoryScan.st"
				if (!seqg_var->moveAxis[seqg_var->j])
					continue;
# line 453 "../MM4005_trajectoryScan.st"
				seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorCurrent[seqg_var->j];
# line 454 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 124/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
			waitEpicsMotors(ssId, pVar);
# line 457 "../MM4005_trajectoryScan.st"
			seqg_var->execState = 0;
# line 458 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 461 "../MM4005_trajectoryScan.st"
			seqg_var->execute = 0;
# line 462 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "readback" in state set "trajectoryScan" ******/

/* Event function for state "readback" in state set "trajectoryScan" */
static seqBool seqg_event_trajectoryScan_0_readback(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "readback" in state set "trajectoryScan" */
static void seqg_action_trajectoryScan_0_readback(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 471 "../MM4005_trajectoryScan.st"
			seqg_var->readState = 1;
# line 472 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 473 "../MM4005_trajectoryScan.st"
			seqg_var->readStatus = 0;
# line 474 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 476 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 477 "../MM4005_trajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < 2000; seqg_var->i++)
				{
# line 478 "../MM4005_trajectoryScan.st"
					seqg_var->motorReadbacks[seqg_var->j][seqg_var->i] = 0.;
# line 479 "../MM4005_trajectoryScan.st"
					seqg_var->motorError[seqg_var->j][seqg_var->i] = 0.;
				}
			}
			writeRead(ssId, pVar, "NQ");
# line 485 "../MM4005_trajectoryScan.st"
			seqg_var->nactual = atoi(&seqg_var->stringIn[2]);
# line 486 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 6/*nactual*/, DEFAULT, DEFAULT_TIMEOUT);
# line 488 "../MM4005_trajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->nactual; seqg_var->i++)
			{
# line 489 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->readMessage, "Reading point %d/%d", seqg_var->i + 1, seqg_var->nactual);
# line 490 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 25/*readMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 491 "../MM4005_trajectoryScan.st"
				sprintf(seqg_var->stringOut, "%dTQ", seqg_var->i + 1);
				writeRead(ssId, pVar, pVar->stringOut);
# line 495 "../MM4005_trajectoryScan.st"
				seqg_var->tok_save = 0;
# line 497 "../MM4005_trajectoryScan.st"
				seqg_var->p = epicsStrtok_r(seqg_var->stringIn, ",", &seqg_var->tok_save);
# line 498 "../MM4005_trajectoryScan.st"
				for (seqg_var->j = 0; (seqg_var->j < seqg_var->numAxes && seqg_var->p != 0); seqg_var->j++)
				{
# line 499 "../MM4005_trajectoryScan.st"
					seqg_var->p = epicsStrtok_r(0, ",", &seqg_var->tok_save);
# line 500 "../MM4005_trajectoryScan.st"
					seqg_var->posTheory = atof(seqg_var->p + 3);
# line 501 "../MM4005_trajectoryScan.st"
					seqg_var->p = epicsStrtok_r(0, ",", &seqg_var->tok_save);
# line 502 "../MM4005_trajectoryScan.st"
					if (seqg_var->epicsMotorDir[seqg_var->j] == 0)
# line 502 "../MM4005_trajectoryScan.st"
						seqg_var->dir = 1;
					else
# line 502 "../MM4005_trajectoryScan.st"
						seqg_var->dir = -1;
# line 503 "../MM4005_trajectoryScan.st"
					seqg_var->posActual = atof(seqg_var->p + 3);
# line 504 "../MM4005_trajectoryScan.st"
					seqg_var->motorError[seqg_var->j][seqg_var->i] = seqg_var->posActual - seqg_var->posTheory;
# line 506 "../MM4005_trajectoryScan.st"
					seqg_var->posActual = seqg_var->posActual * seqg_var->dir + seqg_var->epicsMotorOff[seqg_var->j];
# line 507 "../MM4005_trajectoryScan.st"
					seqg_var->motorReadbacks[seqg_var->j][seqg_var->i] = seqg_var->posActual;
				}
			}
# line 511 "../MM4005_trajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 512 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 44/*motorReadbacks*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 513 "../MM4005_trajectoryScan.st"
				seq_pvPutTmo(seqg_env, 52/*motorError*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 516 "../MM4005_trajectoryScan.st"
			seqg_var->readState = 0;
# line 517 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 519 "../MM4005_trajectoryScan.st"
			seqg_var->readStatus = 1;
# line 520 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 521 "../MM4005_trajectoryScan.st"
			strcpy(seqg_var->readMessage, " ");
# line 522 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 25/*readMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 525 "../MM4005_trajectoryScan.st"
			seqg_var->readback = 0;
# line 526 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 22/*readback*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "monitorAbort" in state set "trajectoryAbort" ******/

/* Event function for state "monitorAbort" in state set "trajectoryAbort" */
static seqBool seqg_event_trajectoryAbort_1_monitorAbort(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 538 "../MM4005_trajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, abortMon) && (seqg_var->abort == 1))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitorAbort" in state set "trajectoryAbort" */
static void seqg_action_trajectoryAbort_1_monitorAbort(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 540 "../MM4005_trajectoryScan.st"
			strcpy(seqg_var->stringOut, "AB");
			writeOnly(ssId, pVar, pVar->stringOut);
# line 542 "../MM4005_trajectoryScan.st"
			seqg_var->execStatus = 3;
# line 543 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 544 "../MM4005_trajectoryScan.st"
			strcpy(seqg_var->execMessage, "Motion aborted");
# line 545 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 548 "../MM4005_trajectoryScan.st"
			seqg_var->abort = 0;
# line 549 "../MM4005_trajectoryScan.st"
			seq_pvPutTmo(seqg_env, 21/*abort*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{P}{R}DebugLevel.VAL", offsetof(struct seqg_vars, debugLevel), "debugLevel", P_INT, 1, 8, 0, 1, 0, 0},
	{"{P}{R}NumAxes.VAL", offsetof(struct seqg_vars, numAxes), "numAxes", P_INT, 1, 9, 0, 1, 0, 0},
	{"{P}{R}Nelements.VAL", offsetof(struct seqg_vars, nelements), "nelements", P_INT, 1, 10, 6, 1, 0, 0},
	{"{P}{R}Npulses.VAL", offsetof(struct seqg_vars, npulses), "npulses", P_INT, 1, 11, 0, 1, 0, 0},
	{"{P}{R}StartPulses.VAL", offsetof(struct seqg_vars, startPulses), "startPulses", P_INT, 1, 12, 0, 1, 0, 0},
	{"{P}{R}EndPulses.VAL", offsetof(struct seqg_vars, endPulses), "endPulses", P_INT, 1, 13, 0, 1, 0, 0},
	{"{P}{R}Nactual.VAL", offsetof(struct seqg_vars, nactual), "nactual", P_INT, 1, 14, 0, 0, 0, 0},
	{"{P}{R}MoveMode.VAL", offsetof(struct seqg_vars, moveMode), "moveMode", P_INT, 1, 15, 0, 1, 0, 0},
	{"{P}{R}Time.VAL", offsetof(struct seqg_vars, time_PV), "time_PV", P_DOUBLE, 1, 16, 0, 1, 0, 0},
	{"{P}{R}TimeScale.VAL", offsetof(struct seqg_vars, timeScale), "timeScale", P_DOUBLE, 1, 17, 0, 1, 0, 0},
	{"{P}{R}TimeMode.VAL", offsetof(struct seqg_vars, timeMode), "timeMode", P_INT, 1, 18, 0, 1, 0, 0},
	{"{P}{R}Accel.VAL", offsetof(struct seqg_vars, accel), "accel", P_DOUBLE, 1, 19, 0, 1, 0, 0},
	{"{P}{R}Build.VAL", offsetof(struct seqg_vars, build), "build", P_INT, 1, 20, 1, 1, 0, 0},
	{"{P}{R}BuildState.VAL", offsetof(struct seqg_vars, buildState), "buildState", P_INT, 1, 21, 0, 0, 0, 0},
	{"{P}{R}BuildStatus.VAL", offsetof(struct seqg_vars, buildStatus), "buildStatus", P_INT, 1, 22, 0, 0, 0, 0},
	{"{P}{R}BuildMessage.VAL", offsetof(struct seqg_vars, buildMessage), "buildMessage", P_STRING, 1, 23, 0, 0, 0, 0},
	{"{P}{R}SimMode.VAL", offsetof(struct seqg_vars, simMode), "simMode", P_INT, 1, 24, 0, 1, 0, 0},
	{"{P}{R}Execute.VAL", offsetof(struct seqg_vars, execute), "execute", P_INT, 1, 25, 2, 1, 0, 0},
	{"{P}{R}ExecState.VAL", offsetof(struct seqg_vars, execState), "execState", P_INT, 1, 26, 3, 1, 0, 0},
	{"{P}{R}ExecStatus.VAL", offsetof(struct seqg_vars, execStatus), "execStatus", P_INT, 1, 27, 0, 0, 0, 0},
	{"{P}{R}ExecMessage.VAL", offsetof(struct seqg_vars, execMessage), "execMessage", P_STRING, 1, 28, 0, 0, 0, 0},
	{"{P}{R}Abort.VAL", offsetof(struct seqg_vars, abort), "abort", P_INT, 1, 29, 4, 1, 0, 0},
	{"{P}{R}Readback.VAL", offsetof(struct seqg_vars, readback), "readback", P_INT, 1, 30, 5, 1, 0, 0},
	{"{P}{R}ReadState.VAL", offsetof(struct seqg_vars, readState), "readState", P_INT, 1, 31, 0, 0, 0, 0},
	{"{P}{R}ReadStatus.VAL", offsetof(struct seqg_vars, readStatus), "readStatus", P_INT, 1, 32, 0, 0, 0, 0},
	{"{P}{R}ReadMessage.VAL", offsetof(struct seqg_vars, readMessage), "readMessage", P_STRING, 1, 33, 0, 0, 0, 0},
	{"{P}{R}TimeTraj.VAL", offsetof(struct seqg_vars, timeTrajectory), "timeTrajectory", P_DOUBLE, 2000, 34, 0, 1, 0, 0},
	{"{P}{R}TrajectoryFile.VAL", offsetof(struct seqg_vars, trajectoryFile), "trajectoryFile", P_STRING, 1, 35, 0, 1, 0, 0},
	{"{P}{R}M1Move.VAL", offsetof(struct seqg_vars, moveAxis[0]), "moveAxis[0]", P_INT, 1, 36, 0, 1, 0, 0},
	{"{P}{R}M2Move.VAL", offsetof(struct seqg_vars, moveAxis[1]), "moveAxis[1]", P_INT, 1, 37, 0, 1, 0, 0},
	{"{P}{R}M3Move.VAL", offsetof(struct seqg_vars, moveAxis[2]), "moveAxis[2]", P_INT, 1, 38, 0, 1, 0, 0},
	{"{P}{R}M4Move.VAL", offsetof(struct seqg_vars, moveAxis[3]), "moveAxis[3]", P_INT, 1, 39, 0, 1, 0, 0},
	{"{P}{R}M5Move.VAL", offsetof(struct seqg_vars, moveAxis[4]), "moveAxis[4]", P_INT, 1, 40, 0, 1, 0, 0},
	{"{P}{R}M6Move.VAL", offsetof(struct seqg_vars, moveAxis[5]), "moveAxis[5]", P_INT, 1, 41, 0, 1, 0, 0},
	{"{P}{R}M7Move.VAL", offsetof(struct seqg_vars, moveAxis[6]), "moveAxis[6]", P_INT, 1, 42, 0, 1, 0, 0},
	{"{P}{R}M8Move.VAL", offsetof(struct seqg_vars, moveAxis[7]), "moveAxis[7]", P_INT, 1, 43, 0, 1, 0, 0},
	{"{P}{R}M1Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[0]), "motorTrajectory[0]", P_DOUBLE, 2000, 44, 0, 1, 0, 0},
	{"{P}{R}M2Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[1]), "motorTrajectory[1]", P_DOUBLE, 2000, 45, 0, 1, 0, 0},
	{"{P}{R}M3Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[2]), "motorTrajectory[2]", P_DOUBLE, 2000, 46, 0, 1, 0, 0},
	{"{P}{R}M4Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[3]), "motorTrajectory[3]", P_DOUBLE, 2000, 47, 0, 1, 0, 0},
	{"{P}{R}M5Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[4]), "motorTrajectory[4]", P_DOUBLE, 2000, 48, 0, 1, 0, 0},
	{"{P}{R}M6Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[5]), "motorTrajectory[5]", P_DOUBLE, 2000, 49, 0, 1, 0, 0},
	{"{P}{R}M7Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[6]), "motorTrajectory[6]", P_DOUBLE, 2000, 50, 0, 1, 0, 0},
	{"{P}{R}M8Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[7]), "motorTrajectory[7]", P_DOUBLE, 2000, 51, 0, 1, 0, 0},
	{"{P}{R}M1Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[0]), "motorReadbacks[0]", P_DOUBLE, 2000, 52, 0, 0, 0, 0},
	{"{P}{R}M2Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[1]), "motorReadbacks[1]", P_DOUBLE, 2000, 53, 0, 0, 0, 0},
	{"{P}{R}M3Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[2]), "motorReadbacks[2]", P_DOUBLE, 2000, 54, 0, 0, 0, 0},
	{"{P}{R}M4Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[3]), "motorReadbacks[3]", P_DOUBLE, 2000, 55, 0, 0, 0, 0},
	{"{P}{R}M5Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[4]), "motorReadbacks[4]", P_DOUBLE, 2000, 56, 0, 0, 0, 0},
	{"{P}{R}M6Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[5]), "motorReadbacks[5]", P_DOUBLE, 2000, 57, 0, 0, 0, 0},
	{"{P}{R}M7Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[6]), "motorReadbacks[6]", P_DOUBLE, 2000, 58, 0, 0, 0, 0},
	{"{P}{R}M8Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[7]), "motorReadbacks[7]", P_DOUBLE, 2000, 59, 0, 0, 0, 0},
	{"{P}{R}M1Error.VAL", offsetof(struct seqg_vars, motorError[0]), "motorError[0]", P_DOUBLE, 2000, 60, 0, 0, 0, 0},
	{"{P}{R}M2Error.VAL", offsetof(struct seqg_vars, motorError[1]), "motorError[1]", P_DOUBLE, 2000, 61, 0, 0, 0, 0},
	{"{P}{R}M3Error.VAL", offsetof(struct seqg_vars, motorError[2]), "motorError[2]", P_DOUBLE, 2000, 62, 0, 0, 0, 0},
	{"{P}{R}M4Error.VAL", offsetof(struct seqg_vars, motorError[3]), "motorError[3]", P_DOUBLE, 2000, 63, 0, 0, 0, 0},
	{"{P}{R}M5Error.VAL", offsetof(struct seqg_vars, motorError[4]), "motorError[4]", P_DOUBLE, 2000, 64, 0, 0, 0, 0},
	{"{P}{R}M6Error.VAL", offsetof(struct seqg_vars, motorError[5]), "motorError[5]", P_DOUBLE, 2000, 65, 0, 0, 0, 0},
	{"{P}{R}M7Error.VAL", offsetof(struct seqg_vars, motorError[6]), "motorError[6]", P_DOUBLE, 2000, 66, 0, 0, 0, 0},
	{"{P}{R}M8Error.VAL", offsetof(struct seqg_vars, motorError[7]), "motorError[7]", P_DOUBLE, 2000, 67, 0, 0, 0, 0},
	{"{P}{R}M1Current.VAL", offsetof(struct seqg_vars, motorCurrent[0]), "motorCurrent[0]", P_DOUBLE, 1, 68, 0, 0, 0, 0},
	{"{P}{R}M2Current.VAL", offsetof(struct seqg_vars, motorCurrent[1]), "motorCurrent[1]", P_DOUBLE, 1, 69, 0, 0, 0, 0},
	{"{P}{R}M3Current.VAL", offsetof(struct seqg_vars, motorCurrent[2]), "motorCurrent[2]", P_DOUBLE, 1, 70, 0, 0, 0, 0},
	{"{P}{R}M4Current.VAL", offsetof(struct seqg_vars, motorCurrent[3]), "motorCurrent[3]", P_DOUBLE, 1, 71, 0, 0, 0, 0},
	{"{P}{R}M5Current.VAL", offsetof(struct seqg_vars, motorCurrent[4]), "motorCurrent[4]", P_DOUBLE, 1, 72, 0, 0, 0, 0},
	{"{P}{R}M6Current.VAL", offsetof(struct seqg_vars, motorCurrent[5]), "motorCurrent[5]", P_DOUBLE, 1, 73, 0, 0, 0, 0},
	{"{P}{R}M7Current.VAL", offsetof(struct seqg_vars, motorCurrent[6]), "motorCurrent[6]", P_DOUBLE, 1, 74, 0, 0, 0, 0},
	{"{P}{R}M8Current.VAL", offsetof(struct seqg_vars, motorCurrent[7]), "motorCurrent[7]", P_DOUBLE, 1, 75, 0, 0, 0, 0},
	{"{P}{R}M1MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[0]), "motorMDVS[0]", P_DOUBLE, 1, 76, 7, 1, 0, 0},
	{"{P}{R}M2MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[1]), "motorMDVS[1]", P_DOUBLE, 1, 77, 7, 1, 0, 0},
	{"{P}{R}M3MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[2]), "motorMDVS[2]", P_DOUBLE, 1, 78, 7, 1, 0, 0},
	{"{P}{R}M4MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[3]), "motorMDVS[3]", P_DOUBLE, 1, 79, 7, 1, 0, 0},
	{"{P}{R}M5MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[4]), "motorMDVS[4]", P_DOUBLE, 1, 80, 7, 1, 0, 0},
	{"{P}{R}M6MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[5]), "motorMDVS[5]", P_DOUBLE, 1, 81, 7, 1, 0, 0},
	{"{P}{R}M7MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[6]), "motorMDVS[6]", P_DOUBLE, 1, 82, 7, 1, 0, 0},
	{"{P}{R}M8MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[7]), "motorMDVS[7]", P_DOUBLE, 1, 83, 7, 1, 0, 0},
	{"{P}{R}M1MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[0]), "motorMDVA[0]", P_DOUBLE, 1, 84, 0, 0, 0, 0},
	{"{P}{R}M2MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[1]), "motorMDVA[1]", P_DOUBLE, 1, 85, 0, 0, 0, 0},
	{"{P}{R}M3MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[2]), "motorMDVA[2]", P_DOUBLE, 1, 86, 0, 0, 0, 0},
	{"{P}{R}M4MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[3]), "motorMDVA[3]", P_DOUBLE, 1, 87, 0, 0, 0, 0},
	{"{P}{R}M5MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[4]), "motorMDVA[4]", P_DOUBLE, 1, 88, 0, 0, 0, 0},
	{"{P}{R}M6MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[5]), "motorMDVA[5]", P_DOUBLE, 1, 89, 0, 0, 0, 0},
	{"{P}{R}M7MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[6]), "motorMDVA[6]", P_DOUBLE, 1, 90, 0, 0, 0, 0},
	{"{P}{R}M8MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[7]), "motorMDVA[7]", P_DOUBLE, 1, 91, 0, 0, 0, 0},
	{"{P}{R}M1MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[0]), "motorMDVE[0]", P_INT, 1, 92, 0, 0, 0, 0},
	{"{P}{R}M2MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[1]), "motorMDVE[1]", P_INT, 1, 93, 0, 0, 0, 0},
	{"{P}{R}M3MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[2]), "motorMDVE[2]", P_INT, 1, 94, 0, 0, 0, 0},
	{"{P}{R}M4MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[3]), "motorMDVE[3]", P_INT, 1, 95, 0, 0, 0, 0},
	{"{P}{R}M5MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[4]), "motorMDVE[4]", P_INT, 1, 96, 0, 0, 0, 0},
	{"{P}{R}M6MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[5]), "motorMDVE[5]", P_INT, 1, 97, 0, 0, 0, 0},
	{"{P}{R}M7MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[6]), "motorMDVE[6]", P_INT, 1, 98, 0, 0, 0, 0},
	{"{P}{R}M8MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[7]), "motorMDVE[7]", P_INT, 1, 99, 0, 0, 0, 0},
	{"{P}{R}M1MVA.VAL", offsetof(struct seqg_vars, motorMVA[0]), "motorMVA[0]", P_DOUBLE, 1, 100, 0, 0, 0, 0},
	{"{P}{R}M2MVA.VAL", offsetof(struct seqg_vars, motorMVA[1]), "motorMVA[1]", P_DOUBLE, 1, 101, 0, 0, 0, 0},
	{"{P}{R}M3MVA.VAL", offsetof(struct seqg_vars, motorMVA[2]), "motorMVA[2]", P_DOUBLE, 1, 102, 0, 0, 0, 0},
	{"{P}{R}M4MVA.VAL", offsetof(struct seqg_vars, motorMVA[3]), "motorMVA[3]", P_DOUBLE, 1, 103, 0, 0, 0, 0},
	{"{P}{R}M5MVA.VAL", offsetof(struct seqg_vars, motorMVA[4]), "motorMVA[4]", P_DOUBLE, 1, 104, 0, 0, 0, 0},
	{"{P}{R}M6MVA.VAL", offsetof(struct seqg_vars, motorMVA[5]), "motorMVA[5]", P_DOUBLE, 1, 105, 0, 0, 0, 0},
	{"{P}{R}M7MVA.VAL", offsetof(struct seqg_vars, motorMVA[6]), "motorMVA[6]", P_DOUBLE, 1, 106, 0, 0, 0, 0},
	{"{P}{R}M8MVA.VAL", offsetof(struct seqg_vars, motorMVA[7]), "motorMVA[7]", P_DOUBLE, 1, 107, 0, 0, 0, 0},
	{"{P}{R}M1MVE.VAL", offsetof(struct seqg_vars, motorMVE[0]), "motorMVE[0]", P_INT, 1, 108, 0, 0, 0, 0},
	{"{P}{R}M2MVE.VAL", offsetof(struct seqg_vars, motorMVE[1]), "motorMVE[1]", P_INT, 1, 109, 0, 0, 0, 0},
	{"{P}{R}M3MVE.VAL", offsetof(struct seqg_vars, motorMVE[2]), "motorMVE[2]", P_INT, 1, 110, 0, 0, 0, 0},
	{"{P}{R}M4MVE.VAL", offsetof(struct seqg_vars, motorMVE[3]), "motorMVE[3]", P_INT, 1, 111, 0, 0, 0, 0},
	{"{P}{R}M5MVE.VAL", offsetof(struct seqg_vars, motorMVE[4]), "motorMVE[4]", P_INT, 1, 112, 0, 0, 0, 0},
	{"{P}{R}M6MVE.VAL", offsetof(struct seqg_vars, motorMVE[5]), "motorMVE[5]", P_INT, 1, 113, 0, 0, 0, 0},
	{"{P}{R}M7MVE.VAL", offsetof(struct seqg_vars, motorMVE[6]), "motorMVE[6]", P_INT, 1, 114, 0, 0, 0, 0},
	{"{P}{R}M8MVE.VAL", offsetof(struct seqg_vars, motorMVE[7]), "motorMVE[7]", P_INT, 1, 115, 0, 0, 0, 0},
	{"{P}{R}M1MAA.VAL", offsetof(struct seqg_vars, motorMAA[0]), "motorMAA[0]", P_DOUBLE, 1, 116, 0, 0, 0, 0},
	{"{P}{R}M2MAA.VAL", offsetof(struct seqg_vars, motorMAA[1]), "motorMAA[1]", P_DOUBLE, 1, 117, 0, 0, 0, 0},
	{"{P}{R}M3MAA.VAL", offsetof(struct seqg_vars, motorMAA[2]), "motorMAA[2]", P_DOUBLE, 1, 118, 0, 0, 0, 0},
	{"{P}{R}M4MAA.VAL", offsetof(struct seqg_vars, motorMAA[3]), "motorMAA[3]", P_DOUBLE, 1, 119, 0, 0, 0, 0},
	{"{P}{R}M5MAA.VAL", offsetof(struct seqg_vars, motorMAA[4]), "motorMAA[4]", P_DOUBLE, 1, 120, 0, 0, 0, 0},
	{"{P}{R}M6MAA.VAL", offsetof(struct seqg_vars, motorMAA[5]), "motorMAA[5]", P_DOUBLE, 1, 121, 0, 0, 0, 0},
	{"{P}{R}M7MAA.VAL", offsetof(struct seqg_vars, motorMAA[6]), "motorMAA[6]", P_DOUBLE, 1, 122, 0, 0, 0, 0},
	{"{P}{R}M8MAA.VAL", offsetof(struct seqg_vars, motorMAA[7]), "motorMAA[7]", P_DOUBLE, 1, 123, 0, 0, 0, 0},
	{"{P}{R}M1MAE.VAL", offsetof(struct seqg_vars, motorMAE[0]), "motorMAE[0]", P_INT, 1, 124, 0, 0, 0, 0},
	{"{P}{R}M2MAE.VAL", offsetof(struct seqg_vars, motorMAE[1]), "motorMAE[1]", P_INT, 1, 125, 0, 0, 0, 0},
	{"{P}{R}M3MAE.VAL", offsetof(struct seqg_vars, motorMAE[2]), "motorMAE[2]", P_INT, 1, 126, 0, 0, 0, 0},
	{"{P}{R}M4MAE.VAL", offsetof(struct seqg_vars, motorMAE[3]), "motorMAE[3]", P_INT, 1, 127, 0, 0, 0, 0},
	{"{P}{R}M5MAE.VAL", offsetof(struct seqg_vars, motorMAE[4]), "motorMAE[4]", P_INT, 1, 128, 0, 0, 0, 0},
	{"{P}{R}M6MAE.VAL", offsetof(struct seqg_vars, motorMAE[5]), "motorMAE[5]", P_INT, 1, 129, 0, 0, 0, 0},
	{"{P}{R}M7MAE.VAL", offsetof(struct seqg_vars, motorMAE[6]), "motorMAE[6]", P_INT, 1, 130, 0, 0, 0, 0},
	{"{P}{R}M8MAE.VAL", offsetof(struct seqg_vars, motorMAE[7]), "motorMAE[7]", P_INT, 1, 131, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[0]), "epicsMotorPos[0]", P_DOUBLE, 1, 132, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[1]), "epicsMotorPos[1]", P_DOUBLE, 1, 133, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[2]), "epicsMotorPos[2]", P_DOUBLE, 1, 134, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[3]), "epicsMotorPos[3]", P_DOUBLE, 1, 135, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[4]), "epicsMotorPos[4]", P_DOUBLE, 1, 136, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[5]), "epicsMotorPos[5]", P_DOUBLE, 1, 137, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[6]), "epicsMotorPos[6]", P_DOUBLE, 1, 138, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[7]), "epicsMotorPos[7]", P_DOUBLE, 1, 139, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[0]), "epicsMotorDir[0]", P_DOUBLE, 1, 140, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[1]), "epicsMotorDir[1]", P_DOUBLE, 1, 141, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[2]), "epicsMotorDir[2]", P_DOUBLE, 1, 142, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[3]), "epicsMotorDir[3]", P_DOUBLE, 1, 143, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[4]), "epicsMotorDir[4]", P_DOUBLE, 1, 144, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[5]), "epicsMotorDir[5]", P_DOUBLE, 1, 145, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[6]), "epicsMotorDir[6]", P_DOUBLE, 1, 146, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[7]), "epicsMotorDir[7]", P_DOUBLE, 1, 147, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[0]), "epicsMotorOff[0]", P_DOUBLE, 1, 148, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[1]), "epicsMotorOff[1]", P_DOUBLE, 1, 149, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[2]), "epicsMotorOff[2]", P_DOUBLE, 1, 150, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[3]), "epicsMotorOff[3]", P_DOUBLE, 1, 151, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[4]), "epicsMotorOff[4]", P_DOUBLE, 1, 152, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[5]), "epicsMotorOff[5]", P_DOUBLE, 1, 153, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[6]), "epicsMotorOff[6]", P_DOUBLE, 1, 154, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[7]), "epicsMotorOff[7]", P_DOUBLE, 1, 155, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[0]), "epicsMotorDone[0]", P_DOUBLE, 1, 156, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[1]), "epicsMotorDone[1]", P_DOUBLE, 1, 157, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[2]), "epicsMotorDone[2]", P_DOUBLE, 1, 158, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[3]), "epicsMotorDone[3]", P_DOUBLE, 1, 159, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[4]), "epicsMotorDone[4]", P_DOUBLE, 1, 160, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[5]), "epicsMotorDone[5]", P_DOUBLE, 1, 161, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[6]), "epicsMotorDone[6]", P_DOUBLE, 1, 162, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[7]), "epicsMotorDone[7]", P_DOUBLE, 1, 163, 0, 1, 0, 0},
};

/* Event masks for state set "trajectoryScan" */
static const seqMask seqg_mask_trajectoryScan_0_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_trajectoryScan_0_monitor_inputs[] = {
	0x421004e6,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_trajectoryScan_0_build[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_trajectoryScan_0_execute[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_trajectoryScan_0_wait_execute[] = {
	0x0c000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_trajectoryScan_0_readback[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "trajectoryScan" */
static seqState seqg_states_trajectoryScan[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_trajectoryScan_0_init,
	/* event function */    seqg_event_trajectoryScan_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryScan_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "monitor_inputs",
	/* action function */   seqg_action_trajectoryScan_0_monitor_inputs,
	/* event function */    seqg_event_trajectoryScan_0_monitor_inputs,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryScan_0_monitor_inputs,
	/* state options */     (0)
	},
	{
	/* state name */        "build",
	/* action function */   seqg_action_trajectoryScan_0_build,
	/* event function */    seqg_event_trajectoryScan_0_build,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryScan_0_build,
	/* state options */     (0)
	},
	{
	/* state name */        "execute",
	/* action function */   seqg_action_trajectoryScan_0_execute,
	/* event function */    seqg_event_trajectoryScan_0_execute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryScan_0_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "wait_execute",
	/* action function */   seqg_action_trajectoryScan_0_wait_execute,
	/* event function */    seqg_event_trajectoryScan_0_wait_execute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryScan_0_wait_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "readback",
	/* action function */   seqg_action_trajectoryScan_0_readback,
	/* event function */    seqg_event_trajectoryScan_0_readback,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryScan_0_readback,
	/* state options */     (0)
	},
};

/* Event masks for state set "trajectoryAbort" */
static const seqMask seqg_mask_trajectoryAbort_1_monitorAbort[] = {
	0x20000010,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "trajectoryAbort" */
static seqState seqg_states_trajectoryAbort[] = {
	{
	/* state name */        "monitorAbort",
	/* action function */   seqg_action_trajectoryAbort_1_monitorAbort,
	/* event function */    seqg_event_trajectoryAbort_1_monitorAbort,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryAbort_1_monitorAbort,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "trajectoryScan",
	/* states */            seqg_states_trajectoryScan,
	/* number of states */  6
	},

	{
	/* state set name */    "trajectoryAbort",
	/* states */            seqg_states_trajectoryAbort,
	/* number of states */  1
	},
};

/* Program table (global) */
seqProgram MM4005_trajectoryScan = {
	/* magic number */      2002001,
	/* program name */      "MM4005_trajectoryScan",
	/* channels */          seqg_chans,
	/* num. channels */     156,
	/* state sets */        seqg_statesets,
	/* num. state sets */   2,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=13IDC:,R=traj1,M1=M1,M2=M2,M3=M3,M4=M4,M5=M5,M6=M6,M7=M7,M8=M8,PORT=serial1",
	/* num. event flags */  7,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 556 "../MM4005_trajectoryScan.st"



static int writeOnly(SS_ID ssId, struct UserVar *pVar, char *command)
{
    asynStatus status;
    size_t nwrite;
    char buffer[256];


    strncpy(buffer, command, 256 -3);
    strcat(buffer, "\r");
    status = pasynOctetSyncIO->write((asynUser *)pVar->pasynUser, buffer,
                               strlen(buffer), 1.0, &nwrite);
    return(status);
}



static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command)
{
    asynStatus status;
    size_t nwrite, nread;
    int eomReason;
    char buffer[256];


    strncpy(buffer, command, 256 -3);
    strcat(buffer, "\r");

    status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, buffer,
                               strlen(buffer), pVar->stringIn, 256,
                               30.0, &nwrite, &nread, &eomReason);
    return(status);
}



static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos)
{
    char *p, *tok_save;
    int j;
    int dir;


    writeRead(ssId, pVar, "TP");


    tok_save = 0;
    p = epicsStrtok_r(pVar->stringIn, ",", &tok_save);
    for (j=0; (j<pVar->numAxes && p!=0); j++) {
        if (pVar->epicsMotorDir[j] == 0) dir=1; else dir=-1;
        pos[j] = atof(p+3)*dir + pVar->epicsMotorOff[j];
        p = epicsStrtok_r(0, ",", &tok_save);
    }
    return(0);
}





static int getMotorMoving(SS_ID ssId, struct UserVar *pVar)
{
    char *p, *tok_save;
    int j;
    int result=0, mask=0x01;


    writeRead(ssId, pVar, "MS");


    tok_save = 0;
    p = epicsStrtok_r(pVar->stringIn, ",", &tok_save);
    for (j=0; (j<pVar->numAxes && p!=0); j++) {

        if (*(p+3) & 0x01) result |= mask;
        mask = mask << 1;
        p = epicsStrtok_r(0, ",", &tok_save);
    }
    return(result);
}




static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar)
{
    int j;
    int result=0, mask=0x01;

    for (j=0; j<pVar->numAxes; j++) {
  seq_pvGet(ssId, pVar->epicsMotorDoneIndex[j], 0);
        if (pVar->epicsMotorDone[j] == 0) result |= mask;
        mask = mask << 1;
    }
    return(result);
}




static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar)
{
    int j;



    while(getEpicsMotorMoving(ssId, pVar)) {

        for (j=0; j<pVar->numAxes; j++) {
            pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
   seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
        }
        epicsThreadSleep(0.1);
    }
    for (j=0; j<pVar->numAxes; j++) {
        pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
  seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
    }
    return(0);
}



/* Register sequencer commands and program */
#include "epicsExport.h"
static void MM4005_trajectoryScanRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&MM4005_trajectoryScan);
}
epicsExportRegistrar(MM4005_trajectoryScanRegistrar);
