/* C code for program snlStepperMotorSequencer, generated by snc from ./../snlStepperMotorSequencer.stt */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 3 "./../snlStepperMotorSequencer.stt"
#include <time.h>
# line 4 "./../snlStepperMotorSequencer.stt"
#include <string.h>
# line 5 "./../snlStepperMotorSequencer.stt"
#include <math.h>
# line 6 "./../snlStepperMotorSequencer.stt"
#include<stdio.h>
# line 7 "./../snlStepperMotorSequencer.stt"
#include<stdlib.h>

/* Variable declarations */
# line 11 "./../snlStepperMotorSequencer.stt"
static	double setCounterValue;
# line 15 "./../snlStepperMotorSequencer.stt"
static	double setCounterControl;
# line 19 "./../snlStepperMotorSequencer.stt"
static	double driveVelocity;
# line 25 "./../snlStepperMotorSequencer.stt"
static	double snlState;
# line 29 "./../snlStepperMotorSequencer.stt"
static	double encCalc;
# line 33 "./../snlStepperMotorSequencer.stt"
static	double encCalc_ENG;
# line 37 "./../snlStepperMotorSequencer.stt"
static	double potChVal;
# line 41 "./../snlStepperMotorSequencer.stt"
static	double potChVal_ENG;
# line 45 "./../snlStepperMotorSequencer.stt"
static	double internalCounterVal;
# line 49 "./../snlStepperMotorSequencer.stt"
static	double internalCounterVal_ENG;
# line 53 "./../snlStepperMotorSequencer.stt"
static	double OUFlowCount;
# line 57 "./../snlStepperMotorSequencer.stt"
static	double snlCLFeedback;
# line 61 "./../snlStepperMotorSequencer.stt"
static	double dist_Encoder;
# line 65 "./../snlStepperMotorSequencer.stt"
static	double dist_Counter;
# line 69 "./../snlStepperMotorSequencer.stt"
static	double dist_Pot;
# line 73 "./../snlStepperMotorSequencer.stt"
static	double snlFailSafe;
# line 77 "./../snlStepperMotorSequencer.stt"
static	double lowerLim;
# line 81 "./../snlStepperMotorSequencer.stt"
static	double isCalibrated;
# line 85 "./../snlStepperMotorSequencer.stt"
static	double offset_Encoder;
# line 89 "./../snlStepperMotorSequencer.stt"
static	double offset_Pot;
# line 93 "./../snlStepperMotorSequencer.stt"
static	double enable_automode;
# line 97 "./../snlStepperMotorSequencer.stt"
static	double setpoint;
# line 101 "./../snlStepperMotorSequencer.stt"
static	double CL_deadband;
# line 105 "./../snlStepperMotorSequencer.stt"
static	double readback;
# line 109 "./../snlStepperMotorSequencer.stt"
static	double driveEnable;
# line 113 "./../snlStepperMotorSequencer.stt"
static	double state_automode;
# line 117 "./../snlStepperMotorSequencer.stt"
static	double CL_enable;
# line 120 "./../snlStepperMotorSequencer.stt"
static	double jog_enable;
# line 123 "./../snlStepperMotorSequencer.stt"
static	double fanout_snlState_val;
# line 126 "./../snlStepperMotorSequencer.stt"
static	double fanout_snlCLFeedback_val;
# line 129 "./../snlStepperMotorSequencer.stt"
static	string CL_FBSensor;
# line 132 "./../snlStepperMotorSequencer.stt"
static	string CL_FSSensor;
# line 135 "./../snlStepperMotorSequencer.stt"
static	double FSErrorLim_val;
# line 139 "./../snlStepperMotorSequencer.stt"
static	double pre_CL_setpoint_dist;
# line 140 "./../snlStepperMotorSequencer.stt"
static	double auto_transition;
# line 142 "./../snlStepperMotorSequencer.stt"
static	double MS_MULT;
# line 143 "./../snlStepperMotorSequencer.stt"
static	struct timespec sleep;


/* Function declarations */
# line 293 "./../snlStepperMotorSequencer.stt"
static void calibrate(SS_ID seqg_env);
# line 422 "./../snlStepperMotorSequencer.stt"
static void calCounterMechEnc(SS_ID seqg_env);
# line 433 "./../snlStepperMotorSequencer.stt"
static void calCounterPot(SS_ID seqg_env);
# line 444 "./../snlStepperMotorSequencer.stt"
static void calCounterSelf(SS_ID seqg_env);
# line 455 "./../snlStepperMotorSequencer.stt"
static void set_CL_setpoint_dist(SS_ID seqg_env);

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
	{
# line 142 "./../snlStepperMotorSequencer.stt"
	static double seqg_initvar_MS_MULT = 1000000;
	memcpy(&MS_MULT, &seqg_initvar_MS_MULT, sizeof(seqg_initvar_MS_MULT));
	}
}

/****** Code for state "PowerOnReset_delay_state" in state set "ss1" ******/

/* Event function for state "PowerOnReset_delay_state" in state set "ss1" */
static seqBool seqg_event_ss1_0_PowerOnReset_delay_state(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 147 "./../snlStepperMotorSequencer.stt"
	if (seq_delay(seqg_env, 0.5))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "PowerOnReset_delay_state" in state set "ss1" */
static void seqg_action_ss1_0_PowerOnReset_delay_state(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "PowerOnReset_state" in state set "ss1" ******/

/* Entry function for state "PowerOnReset_state" in state set "ss1" */
static void seqg_entry_ss1_0_PowerOnReset_state(SS_ID seqg_env)
{
# line 153 "./../snlStepperMotorSequencer.stt"
	printf("Entry PowerOnReset_state\n\r");
# line 155 "./../snlStepperMotorSequencer.stt"
	state_automode = 0;
# line 156 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 25/*state_automode*/, SYNC, DEFAULT_TIMEOUT);
# line 157 "./../snlStepperMotorSequencer.stt"
	snlState = 0;
# line 158 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 3/*snlState*/, SYNC, DEFAULT_TIMEOUT);
# line 159 "./../snlStepperMotorSequencer.stt"
	CL_enable = 0;
# line 160 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 26/*CL_enable*/, SYNC, DEFAULT_TIMEOUT);
# line 161 "./../snlStepperMotorSequencer.stt"
	jog_enable = 0;
# line 162 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 27/*jog_enable*/, SYNC, DEFAULT_TIMEOUT);
# line 163 "./../snlStepperMotorSequencer.stt"
	fanout_snlState_val = 1;
# line 164 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 28/*fanout_snlState_val*/, SYNC, DEFAULT_TIMEOUT);
# line 165 "./../snlStepperMotorSequencer.stt"
	setCounterControl = 0;
# line 166 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 1/*setCounterControl*/, SYNC, DEFAULT_TIMEOUT);
# line 167 "./../snlStepperMotorSequencer.stt"
	set_CL_setpoint_dist(seqg_env);
# line 169 "./../snlStepperMotorSequencer.stt"
	if (isCalibrated == 0)
	{
# line 171 "./../snlStepperMotorSequencer.stt"
		sleep.tv_nsec = (int)(500 * MS_MULT);
# line 172 "./../snlStepperMotorSequencer.stt"
		nanosleep(&sleep, NULL);
# line 173 "./../snlStepperMotorSequencer.stt"
		calibrate(seqg_env);
	}
# line 175 "./../snlStepperMotorSequencer.stt"
	printf("CL DISABLED | JOG DISABLED | FANOUT 1\n\r");
}

/* Event function for state "PowerOnReset_state" in state set "ss1" */
static seqBool seqg_event_ss1_0_PowerOnReset_state(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 177 "./../snlStepperMotorSequencer.stt"
	if (snlState == 1)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 186 "./../snlStepperMotorSequencer.stt"
	if (snlState == 2)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 192 "./../snlStepperMotorSequencer.stt"
	if ((enable_automode == 1) && (fabs(setpoint - readback) > CL_deadband))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "PowerOnReset_state" in state set "ss1" */
static void seqg_action_ss1_0_PowerOnReset_state(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 178 "./../snlStepperMotorSequencer.stt"
			printf("##Requested CL_state\n\r");
# line 179 "./../snlStepperMotorSequencer.stt"
			isCalibrated = 0;
# line 180 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 17/*isCalibrated*/, SYNC, DEFAULT_TIMEOUT);
# line 181 "./../snlStepperMotorSequencer.stt"
			calibrate(seqg_env);
# line 183 "./../snlStepperMotorSequencer.stt"
			pre_CL_setpoint_dist = setpoint;
# line 184 "./../snlStepperMotorSequencer.stt"
			auto_transition = 0;
		}
		return;
	case 1:
		{
# line 187 "./../snlStepperMotorSequencer.stt"
			printf("##Requested OL_state\n\r");
# line 188 "./../snlStepperMotorSequencer.stt"
			isCalibrated = 0;
# line 189 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 17/*isCalibrated*/, SYNC, DEFAULT_TIMEOUT);
# line 190 "./../snlStepperMotorSequencer.stt"
			calibrate(seqg_env);
		}
		return;
	case 2:
		{
# line 193 "./../snlStepperMotorSequencer.stt"
			printf("##AUTO Requested CL_state\n\r");
# line 195 "./../snlStepperMotorSequencer.stt"
			pre_CL_setpoint_dist = setpoint;
# line 196 "./../snlStepperMotorSequencer.stt"
			auto_transition = 1;
# line 198 "./../snlStepperMotorSequencer.stt"
			snlState = 1;
# line 199 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 3/*snlState*/, SYNC, DEFAULT_TIMEOUT);
# line 200 "./../snlStepperMotorSequencer.stt"
			isCalibrated = 0;
# line 201 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 17/*isCalibrated*/, SYNC, DEFAULT_TIMEOUT);
# line 202 "./../snlStepperMotorSequencer.stt"
			calibrate(seqg_env);
		}
		return;
	}
}

/****** Code for state "CL_delay_state" in state set "ss1" ******/

/* Event function for state "CL_delay_state" in state set "ss1" */
static seqBool seqg_event_ss1_0_CL_delay_state(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 206 "./../snlStepperMotorSequencer.stt"
	if (seq_delay(seqg_env, 0.5))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "CL_delay_state" in state set "ss1" */
static void seqg_action_ss1_0_CL_delay_state(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "CL_state" in state set "ss1" ******/

/* Entry function for state "CL_state" in state set "ss1" */
static void seqg_entry_ss1_0_CL_state(SS_ID seqg_env)
{
# line 212 "./../snlStepperMotorSequencer.stt"
	printf("Entry CL_state\n\r");
# line 214 "./../snlStepperMotorSequencer.stt"
	state_automode = 1;
# line 215 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 25/*state_automode*/, SYNC, DEFAULT_TIMEOUT);
# line 216 "./../snlStepperMotorSequencer.stt"
	snlState = 1;
# line 217 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 3/*snlState*/, SYNC, DEFAULT_TIMEOUT);
# line 218 "./../snlStepperMotorSequencer.stt"
	CL_enable = 1;
# line 219 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 26/*CL_enable*/, SYNC, DEFAULT_TIMEOUT);
# line 220 "./../snlStepperMotorSequencer.stt"
	jog_enable = 0;
# line 221 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 27/*jog_enable*/, SYNC, DEFAULT_TIMEOUT);
# line 222 "./../snlStepperMotorSequencer.stt"
	fanout_snlState_val = 2;
# line 223 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 28/*fanout_snlState_val*/, SYNC, DEFAULT_TIMEOUT);
# line 224 "./../snlStepperMotorSequencer.stt"
	setCounterControl = 0;
# line 225 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 1/*setCounterControl*/, SYNC, DEFAULT_TIMEOUT);
# line 226 "./../snlStepperMotorSequencer.stt"
	printf("CL ENABLED | JOG DISABLED | FANOUT 2\n\r");
# line 227 "./../snlStepperMotorSequencer.stt"
	if (enable_automode == 1)
	{
# line 229 "./../snlStepperMotorSequencer.stt"
		setpoint = pre_CL_setpoint_dist;
# line 230 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
# line 231 "./../snlStepperMotorSequencer.stt"
		if (fabs(setpoint - readback) > CL_deadband)
		{
# line 232 "./../snlStepperMotorSequencer.stt"
			driveEnable = 1;
# line 233 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 24/*driveEnable*/, SYNC, DEFAULT_TIMEOUT);
		}
	}
}

/* Event function for state "CL_state" in state set "ss1" */
static seqBool seqg_event_ss1_0_CL_state(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 237 "./../snlStepperMotorSequencer.stt"
	if (snlState == 0)
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 242 "./../snlStepperMotorSequencer.stt"
	if (snlState == 2)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 247 "./../snlStepperMotorSequencer.stt"
	if (enable_automode == 1 && auto_transition == 1 && driveEnable == 0)
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "CL_state" in state set "ss1" */
static void seqg_action_ss1_0_CL_state(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 238 "./../snlStepperMotorSequencer.stt"
			printf("##Requested PowerOnReset_state\n\r");
# line 239 "./../snlStepperMotorSequencer.stt"
			CL_enable = 0;
# line 240 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 26/*CL_enable*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 243 "./../snlStepperMotorSequencer.stt"
			printf("##Requested OL_state\n\r");
# line 244 "./../snlStepperMotorSequencer.stt"
			CL_enable = 0;
# line 245 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 26/*CL_enable*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 248 "./../snlStepperMotorSequencer.stt"
			printf("##AUTO Requested PowerOnReset_state\n\r");
# line 250 "./../snlStepperMotorSequencer.stt"
			snlState = 0;
# line 251 "./../snlStepperMotorSequencer.stt"
			CL_enable = 0;
# line 252 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 26/*CL_enable*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "OL_delay_state" in state set "ss1" ******/

/* Event function for state "OL_delay_state" in state set "ss1" */
static seqBool seqg_event_ss1_0_OL_delay_state(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 256 "./../snlStepperMotorSequencer.stt"
	if (seq_delay(seqg_env, 0.5))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "OL_delay_state" in state set "ss1" */
static void seqg_action_ss1_0_OL_delay_state(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "OL_state" in state set "ss1" ******/

/* Entry function for state "OL_state" in state set "ss1" */
static void seqg_entry_ss1_0_OL_state(SS_ID seqg_env)
{
# line 262 "./../snlStepperMotorSequencer.stt"
	printf("Entry OL_state\n\r");
# line 263 "./../snlStepperMotorSequencer.stt"
	snlState = 2;
# line 264 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 3/*snlState*/, SYNC, DEFAULT_TIMEOUT);
# line 265 "./../snlStepperMotorSequencer.stt"
	CL_enable = 0;
# line 266 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 26/*CL_enable*/, SYNC, DEFAULT_TIMEOUT);
# line 267 "./../snlStepperMotorSequencer.stt"
	jog_enable = 1;
# line 268 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 27/*jog_enable*/, SYNC, DEFAULT_TIMEOUT);
# line 269 "./../snlStepperMotorSequencer.stt"
	fanout_snlState_val = 3;
# line 270 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 28/*fanout_snlState_val*/, SYNC, DEFAULT_TIMEOUT);
# line 271 "./../snlStepperMotorSequencer.stt"
	setCounterControl = 0;
# line 272 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 1/*setCounterControl*/, SYNC, DEFAULT_TIMEOUT);
# line 273 "./../snlStepperMotorSequencer.stt"
	printf("CL DISABLED | JOG ENABLED | FANOUT 3\n\r");
}

/* Event function for state "OL_state" in state set "ss1" */
static seqBool seqg_event_ss1_0_OL_state(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 275 "./../snlStepperMotorSequencer.stt"
	if (snlState == 0)
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 280 "./../snlStepperMotorSequencer.stt"
	if (snlState == 1)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "OL_state" in state set "ss1" */
static void seqg_action_ss1_0_OL_state(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 276 "./../snlStepperMotorSequencer.stt"
			printf("##Requested PowerOnReset_state\n\r");
# line 277 "./../snlStepperMotorSequencer.stt"
			jog_enable = 0;
# line 278 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 27/*jog_enable*/, SYNC, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
# line 281 "./../snlStepperMotorSequencer.stt"
			printf("##Requested CL_state\n\r");
# line 282 "./../snlStepperMotorSequencer.stt"
			jog_enable = 0;
# line 283 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 27/*jog_enable*/, SYNC, DEFAULT_TIMEOUT);
# line 285 "./../snlStepperMotorSequencer.stt"
			set_CL_setpoint_dist(seqg_env);
# line 287 "./../snlStepperMotorSequencer.stt"
			pre_CL_setpoint_dist = setpoint;
# line 288 "./../snlStepperMotorSequencer.stt"
			auto_transition = 0;
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{MotorDrive}:ENCCONTROLCOMPACT:SETCOUNTERVALUE", (size_t)&setCounterValue, "setCounterValue", P_DOUBLE, 1, 1, 0, 1, 0, 0},
	{"{MotorDrive}:ENCCONTROLCOMPACT:CONTROL__SETCOUNTER", (size_t)&setCounterControl, "setCounterControl", P_DOUBLE, 1, 2, 0, 1, 0, 0},
	{"{MotorDrive}:STMVELOCITY:VELOCITY", (size_t)&driveVelocity, "driveVelocity", P_DOUBLE, 1, 3, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:snlState", (size_t)&snlState, "snlState", P_DOUBLE, 1, 4, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:encCalc", (size_t)&encCalc, "encCalc", P_DOUBLE, 1, 5, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:encCalc_ENG", (size_t)&encCalc_ENG, "encCalc_ENG", P_DOUBLE, 1, 6, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:potChVal", (size_t)&potChVal, "potChVal", P_DOUBLE, 1, 7, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:potChVal_ENG", (size_t)&potChVal_ENG, "potChVal_ENG", P_DOUBLE, 1, 8, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:internalCounterVal", (size_t)&internalCounterVal, "internalCounterVal", P_DOUBLE, 1, 9, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:internalCounterVal_ENG", (size_t)&internalCounterVal_ENG, "internalCounterVal_ENG", P_DOUBLE, 1, 10, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:OUFlowCount", (size_t)&OUFlowCount, "OUFlowCount", P_DOUBLE, 1, 11, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:snlCLFeedback", (size_t)&snlCLFeedback, "snlCLFeedback", P_DOUBLE, 1, 12, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:dist_Encoder", (size_t)&dist_Encoder, "dist_Encoder", P_DOUBLE, 1, 13, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:dist_Counter", (size_t)&dist_Counter, "dist_Counter", P_DOUBLE, 1, 14, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:dist_Pot", (size_t)&dist_Pot, "dist_Pot", P_DOUBLE, 1, 15, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:snlFailSafe", (size_t)&snlFailSafe, "snlFailSafe", P_DOUBLE, 1, 16, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:lowerLim", (size_t)&lowerLim, "lowerLim", P_DOUBLE, 1, 17, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:isCalibrated", (size_t)&isCalibrated, "isCalibrated", P_DOUBLE, 1, 18, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:offset_Encoder", (size_t)&offset_Encoder, "offset_Encoder", P_DOUBLE, 1, 19, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:offset_Pot", (size_t)&offset_Pot, "offset_Pot", P_DOUBLE, 1, 20, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:enable_automode", (size_t)&enable_automode, "enable_automode", P_DOUBLE, 1, 21, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:setpoint", (size_t)&setpoint, "setpoint", P_DOUBLE, 1, 22, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:CL_deadband", (size_t)&CL_deadband, "CL_deadband", P_DOUBLE, 1, 23, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:readback", (size_t)&readback, "readback", P_DOUBLE, 1, 24, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:driveEnable", (size_t)&driveEnable, "driveEnable", P_DOUBLE, 1, 25, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:state_automode", (size_t)&state_automode, "state_automode", P_DOUBLE, 1, 26, 0, 1, 0, 0},
	{"{IOC}:{DEVICE}:CL_enable", (size_t)&CL_enable, "CL_enable", P_DOUBLE, 1, 27, 0, 0, 0, 0},
	{"{IOC}:{DEVICE}:jog_enable", (size_t)&jog_enable, "jog_enable", P_DOUBLE, 1, 28, 0, 0, 0, 0},
	{"{IOC}:{DEVICE}:fanout_snlState_val", (size_t)&fanout_snlState_val, "fanout_snlState_val", P_DOUBLE, 1, 29, 0, 0, 0, 0},
	{"{IOC}:{DEVICE}:fanout_snlCLFeedback_val", (size_t)&fanout_snlCLFeedback_val, "fanout_snlCLFeedback_val", P_DOUBLE, 1, 30, 0, 0, 0, 0},
	{"{IOC}:{DEVICE}:CL_FBSensor", (size_t)&CL_FBSensor, "CL_FBSensor", P_STRING, 1, 31, 0, 0, 0, 0},
	{"{IOC}:{DEVICE}:CL_FSSensor", (size_t)&CL_FSSensor, "CL_FSSensor", P_STRING, 1, 32, 0, 0, 0, 0},
	{"{IOC}:{DEVICE}:FSErrorLim_val", (size_t)&FSErrorLim_val, "FSErrorLim_val", P_DOUBLE, 1, 33, 0, 0, 0, 0},
};

/* Event masks for state set "ss1" */
static const seqMask seqg_mask_ss1_0_PowerOnReset_delay_state[] = {
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ss1_0_PowerOnReset_state[] = {
	0x01e00010,
	0x00000000,
};
static const seqMask seqg_mask_ss1_0_CL_delay_state[] = {
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ss1_0_CL_state[] = {
	0x02200010,
	0x00000000,
};
static const seqMask seqg_mask_ss1_0_OL_delay_state[] = {
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_ss1_0_OL_state[] = {
	0x00000010,
	0x00000000,
};

/* State table for state set "ss1" */
static seqState seqg_states_ss1[] = {
	{
	/* state name */        "PowerOnReset_delay_state",
	/* action function */   seqg_action_ss1_0_PowerOnReset_delay_state,
	/* event function */    seqg_event_ss1_0_PowerOnReset_delay_state,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ss1_0_PowerOnReset_delay_state,
	/* state options */     (0)
	},
	{
	/* state name */        "PowerOnReset_state",
	/* action function */   seqg_action_ss1_0_PowerOnReset_state,
	/* event function */    seqg_event_ss1_0_PowerOnReset_state,
	/* entry function */    seqg_entry_ss1_0_PowerOnReset_state,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ss1_0_PowerOnReset_state,
	/* state options */     (0)
	},
	{
	/* state name */        "CL_delay_state",
	/* action function */   seqg_action_ss1_0_CL_delay_state,
	/* event function */    seqg_event_ss1_0_CL_delay_state,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ss1_0_CL_delay_state,
	/* state options */     (0)
	},
	{
	/* state name */        "CL_state",
	/* action function */   seqg_action_ss1_0_CL_state,
	/* event function */    seqg_event_ss1_0_CL_state,
	/* entry function */    seqg_entry_ss1_0_CL_state,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ss1_0_CL_state,
	/* state options */     (0)
	},
	{
	/* state name */        "OL_delay_state",
	/* action function */   seqg_action_ss1_0_OL_delay_state,
	/* event function */    seqg_event_ss1_0_OL_delay_state,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ss1_0_OL_delay_state,
	/* state options */     (0)
	},
	{
	/* state name */        "OL_state",
	/* action function */   seqg_action_ss1_0_OL_state,
	/* event function */    seqg_event_ss1_0_OL_state,
	/* entry function */    seqg_entry_ss1_0_OL_state,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ss1_0_OL_state,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "ss1",
	/* states */            seqg_states_ss1,
	/* number of states */  6
	},
};

/* Program table (global) */
seqProgram snlStepperMotorSequencer = {
	/* magic number */      2002001,
	/* program name */      "snlStepperMotorSequencer",
	/* channels */          seqg_chans,
	/* num. channels */     33,
	/* state sets */        seqg_statesets,
	/* num. state sets */   1,
	/* user var size */     0,
	/* param */             "",
	/* num. event flags */  0,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};

#define seqg_var (*(struct seqg_vars *const *)seqg_env)
# line 293 "./../snlStepperMotorSequencer.stt"
static void calibrate(SS_ID seqg_env)
{
# line 295 "./../snlStepperMotorSequencer.stt"
	if (snlCLFeedback == 0)
	{
# line 296 "./../snlStepperMotorSequencer.stt"
		if (snlFailSafe == 0)
		{
# line 298 "./../snlStepperMotorSequencer.stt"
			calCounterMechEnc(seqg_env);
# line 299 "./../snlStepperMotorSequencer.stt"
			strcpy(CL_FSSensor, "MECHANICAL ENCODER");
# line 300 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
# line 301 "./../snlStepperMotorSequencer.stt"
			FSErrorLim_val = 1;
# line 302 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
		}
		else
# line 304 "./../snlStepperMotorSequencer.stt"
			if (snlFailSafe == 1)
			{
# line 306 "./../snlStepperMotorSequencer.stt"
				calCounterPot(seqg_env);
# line 307 "./../snlStepperMotorSequencer.stt"
				strcpy(CL_FSSensor, "POTENTIOMETER");
# line 308 "./../snlStepperMotorSequencer.stt"
				seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
# line 309 "./../snlStepperMotorSequencer.stt"
				FSErrorLim_val = 2;
# line 310 "./../snlStepperMotorSequencer.stt"
				seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
			}
			else
# line 312 "./../snlStepperMotorSequencer.stt"
				if (snlFailSafe == 2)
				{
# line 314 "./../snlStepperMotorSequencer.stt"
					calCounterMechEnc(seqg_env);
# line 315 "./../snlStepperMotorSequencer.stt"
					strcpy(CL_FSSensor, "INTERNAL COUNTER");
# line 316 "./../snlStepperMotorSequencer.stt"
					seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
# line 317 "./../snlStepperMotorSequencer.stt"
					FSErrorLim_val = 3;
# line 318 "./../snlStepperMotorSequencer.stt"
					seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
				}
				else
				{
				}
# line 325 "./../snlStepperMotorSequencer.stt"
		setpoint = encCalc_ENG;
# line 326 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
# line 328 "./../snlStepperMotorSequencer.stt"
		fanout_snlCLFeedback_val = 1;
# line 329 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 29/*fanout_snlCLFeedback_val*/, SYNC, DEFAULT_TIMEOUT);
# line 331 "./../snlStepperMotorSequencer.stt"
		strcpy(CL_FBSensor, "MECHANICAL ENCODER");
# line 332 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 30/*CL_FBSensor*/, SYNC, DEFAULT_TIMEOUT);
	}
# line 334 "./../snlStepperMotorSequencer.stt"
	if (snlCLFeedback == 1)
	{
# line 335 "./../snlStepperMotorSequencer.stt"
		if (snlFailSafe == 0)
		{
# line 337 "./../snlStepperMotorSequencer.stt"
			calCounterMechEnc(seqg_env);
# line 338 "./../snlStepperMotorSequencer.stt"
			strcpy(CL_FSSensor, "MECHANICAL ENCODER");
# line 339 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
# line 340 "./../snlStepperMotorSequencer.stt"
			FSErrorLim_val = 2;
# line 341 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
		}
		else
# line 343 "./../snlStepperMotorSequencer.stt"
			if (snlFailSafe == 1)
			{
# line 345 "./../snlStepperMotorSequencer.stt"
				calCounterPot(seqg_env);
# line 346 "./../snlStepperMotorSequencer.stt"
				strcpy(CL_FSSensor, "POTENTIOMETER");
# line 347 "./../snlStepperMotorSequencer.stt"
				seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
# line 348 "./../snlStepperMotorSequencer.stt"
				FSErrorLim_val = 1;
# line 349 "./../snlStepperMotorSequencer.stt"
				seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
			}
			else
# line 351 "./../snlStepperMotorSequencer.stt"
				if (snlFailSafe == 2)
				{
# line 353 "./../snlStepperMotorSequencer.stt"
					calCounterPot(seqg_env);
# line 354 "./../snlStepperMotorSequencer.stt"
					strcpy(CL_FSSensor, "INTERNAL COUNTER");
# line 355 "./../snlStepperMotorSequencer.stt"
					seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
# line 356 "./../snlStepperMotorSequencer.stt"
					FSErrorLim_val = 4;
# line 357 "./../snlStepperMotorSequencer.stt"
					seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
				}
				else
				{
				}
# line 364 "./../snlStepperMotorSequencer.stt"
		setpoint = potChVal_ENG;
# line 365 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
# line 367 "./../snlStepperMotorSequencer.stt"
		fanout_snlCLFeedback_val = 2;
# line 368 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 29/*fanout_snlCLFeedback_val*/, SYNC, DEFAULT_TIMEOUT);
# line 370 "./../snlStepperMotorSequencer.stt"
		strcpy(CL_FBSensor, "POTENTIOMETER");
# line 371 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 30/*CL_FBSensor*/, SYNC, DEFAULT_TIMEOUT);
	}
# line 373 "./../snlStepperMotorSequencer.stt"
	if (snlCLFeedback == 2)
	{
# line 374 "./../snlStepperMotorSequencer.stt"
		if (snlFailSafe == 0)
		{
# line 376 "./../snlStepperMotorSequencer.stt"
			FSErrorLim_val = 3;
# line 377 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
# line 378 "./../snlStepperMotorSequencer.stt"
			calCounterMechEnc(seqg_env);
# line 380 "./../snlStepperMotorSequencer.stt"
			setpoint = encCalc_ENG;
# line 381 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
# line 382 "./../snlStepperMotorSequencer.stt"
			strcpy(CL_FSSensor, "MECHANICAL ENCODER");
# line 383 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
		}
		else
# line 385 "./../snlStepperMotorSequencer.stt"
			if (snlFailSafe == 1)
			{
# line 387 "./../snlStepperMotorSequencer.stt"
				FSErrorLim_val = 4;
# line 388 "./../snlStepperMotorSequencer.stt"
				seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
# line 389 "./../snlStepperMotorSequencer.stt"
				calCounterPot(seqg_env);
# line 391 "./../snlStepperMotorSequencer.stt"
				setpoint = potChVal_ENG;
# line 392 "./../snlStepperMotorSequencer.stt"
				seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
# line 393 "./../snlStepperMotorSequencer.stt"
				strcpy(CL_FSSensor, "POTENTIOMETER");
# line 394 "./../snlStepperMotorSequencer.stt"
				seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
			}
			else
# line 396 "./../snlStepperMotorSequencer.stt"
				if (snlFailSafe == 2)
				{
# line 398 "./../snlStepperMotorSequencer.stt"
					FSErrorLim_val = 1;
# line 399 "./../snlStepperMotorSequencer.stt"
					seq_pvPutTmo(seqg_env, 32/*FSErrorLim_val*/, SYNC, DEFAULT_TIMEOUT);
# line 400 "./../snlStepperMotorSequencer.stt"
					calCounterSelf(seqg_env);
# line 402 "./../snlStepperMotorSequencer.stt"
					setpoint = lowerLim;
# line 403 "./../snlStepperMotorSequencer.stt"
					seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
# line 404 "./../snlStepperMotorSequencer.stt"
					strcpy(CL_FSSensor, "INTERNAL COUNTER");
# line 405 "./../snlStepperMotorSequencer.stt"
					seq_pvPutTmo(seqg_env, 31/*CL_FSSensor*/, SYNC, DEFAULT_TIMEOUT);
				}
				else
				{
				}
# line 412 "./../snlStepperMotorSequencer.stt"
		fanout_snlCLFeedback_val = 3;
# line 413 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 29/*fanout_snlCLFeedback_val*/, SYNC, DEFAULT_TIMEOUT);
# line 415 "./../snlStepperMotorSequencer.stt"
		strcpy(CL_FBSensor, "INTERNAL COUNTER");
# line 416 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 30/*CL_FBSensor*/, SYNC, DEFAULT_TIMEOUT);
	}
# line 418 "./../snlStepperMotorSequencer.stt"
	isCalibrated = 1;
# line 419 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 17/*isCalibrated*/, SYNC, DEFAULT_TIMEOUT);
}
#undef seqg_var

#define seqg_var (*(struct seqg_vars *const *)seqg_env)
# line 422 "./../snlStepperMotorSequencer.stt"
static void calCounterMechEnc(SS_ID seqg_env)
{
# line 425 "./../snlStepperMotorSequencer.stt"
	setCounterValue = 0;
# line 426 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 0/*setCounterValue*/, SYNC, DEFAULT_TIMEOUT);
# line 427 "./../snlStepperMotorSequencer.stt"
	setCounterControl = 1;
# line 428 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 1/*setCounterControl*/, SYNC, DEFAULT_TIMEOUT);
# line 429 "./../snlStepperMotorSequencer.stt"
	OUFlowCount = (offset_Encoder + encCalc / dist_Encoder) * dist_Counter;
# line 430 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 10/*OUFlowCount*/, SYNC, DEFAULT_TIMEOUT);
}
#undef seqg_var

#define seqg_var (*(struct seqg_vars *const *)seqg_env)
# line 433 "./../snlStepperMotorSequencer.stt"
static void calCounterPot(SS_ID seqg_env)
{
# line 436 "./../snlStepperMotorSequencer.stt"
	setCounterValue = 0;
# line 437 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 0/*setCounterValue*/, SYNC, DEFAULT_TIMEOUT);
# line 438 "./../snlStepperMotorSequencer.stt"
	setCounterControl = 1;
# line 439 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 1/*setCounterControl*/, SYNC, DEFAULT_TIMEOUT);
# line 440 "./../snlStepperMotorSequencer.stt"
	OUFlowCount = (offset_Pot + potChVal / dist_Pot) * dist_Counter;
# line 441 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 10/*OUFlowCount*/, SYNC, DEFAULT_TIMEOUT);
}
#undef seqg_var

#define seqg_var (*(struct seqg_vars *const *)seqg_env)
# line 444 "./../snlStepperMotorSequencer.stt"
static void calCounterSelf(SS_ID seqg_env)
{
# line 447 "./../snlStepperMotorSequencer.stt"
	setCounterValue = 0;
# line 448 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 0/*setCounterValue*/, SYNC, DEFAULT_TIMEOUT);
# line 449 "./../snlStepperMotorSequencer.stt"
	setCounterControl = 1;
# line 450 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 1/*setCounterControl*/, SYNC, DEFAULT_TIMEOUT);
# line 451 "./../snlStepperMotorSequencer.stt"
	OUFlowCount = lowerLim * dist_Counter;
# line 452 "./../snlStepperMotorSequencer.stt"
	seq_pvPutTmo(seqg_env, 10/*OUFlowCount*/, SYNC, DEFAULT_TIMEOUT);
}
#undef seqg_var

#define seqg_var (*(struct seqg_vars *const *)seqg_env)
# line 455 "./../snlStepperMotorSequencer.stt"
static void set_CL_setpoint_dist(SS_ID seqg_env)
{
# line 456 "./../snlStepperMotorSequencer.stt"
	if (snlCLFeedback == 0)
	{
# line 457 "./../snlStepperMotorSequencer.stt"
		setpoint = encCalc_ENG;
# line 458 "./../snlStepperMotorSequencer.stt"
		seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
	}
	else
# line 460 "./../snlStepperMotorSequencer.stt"
		if (snlCLFeedback == 1)
		{
# line 461 "./../snlStepperMotorSequencer.stt"
			setpoint = potChVal_ENG;
# line 462 "./../snlStepperMotorSequencer.stt"
			seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
		}
		else
# line 464 "./../snlStepperMotorSequencer.stt"
			if (snlCLFeedback == 2)
			{
# line 465 "./../snlStepperMotorSequencer.stt"
				setpoint = internalCounterVal_ENG;
# line 466 "./../snlStepperMotorSequencer.stt"
				seq_pvPutTmo(seqg_env, 21/*setpoint*/, SYNC, DEFAULT_TIMEOUT);
			}
}
#undef seqg_var

#define PROG_NAME snlStepperMotorSequencer
#include "seqMain.c"

/* Register sequencer commands and program */
#include "epicsExport.h"
static void snlStepperMotorSequencerRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&snlStepperMotorSequencer);
}
epicsExportRegistrar(snlStepperMotorSequencerRegistrar);
